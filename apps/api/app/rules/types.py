"""Pydantic models for the Rules system.

All models use ``model_config = ConfigDict(frozen=True)`` so serialized JSON
shapes are stable and safe to pass between LangGraph nodes.
"""

from __future__ import annotations

from enum import StrEnum

from pydantic import BaseModel, ConfigDict, Field

# ---------------------------------------------------------------------------
# Enums
# ---------------------------------------------------------------------------


class Severity(StrEnum):
    """How strictly a rule must be enforced."""

    MUST = "must"
    SHOULD = "should"
    MAY = "may"


class Scope(StrEnum):
    """Where a rule applies."""

    PROJECT = "project"
    MODULE = "module"


# ---------------------------------------------------------------------------
# Core rule models
# ---------------------------------------------------------------------------


class GlobalRule(BaseModel):
    """A platform-defined rule that takes absolute precedence."""

    model_config = ConfigDict(frozen=True)

    id: str = Field(..., description="Unique, stable identifier, e.g. 'G-001'.")
    title: str = Field(..., min_length=1, max_length=200)
    description: str = Field(default="", max_length=2000)
    severity: Severity = Field(default=Severity.MUST)
    scope: Scope = Field(default=Scope.PROJECT)


class UserRule(BaseModel):
    """A rule submitted by the end-user (or generated by an upstream agent)."""

    model_config = ConfigDict(frozen=True)

    id: str = Field(..., description="Unique identifier, e.g. 'U-001'.")
    title: str = Field(..., min_length=1, max_length=200)
    description: str = Field(default="", max_length=2000)
    severity: Severity = Field(default=Severity.SHOULD)
    scope: Scope = Field(default=Scope.PROJECT)
    module: str | None = Field(
        default=None,
        description="If scope == MODULE, the target module name.",
    )


# ---------------------------------------------------------------------------
# Decision / adjudication result models
# ---------------------------------------------------------------------------


class RuleDecision(BaseModel):
    """The outcome for a single user rule after adjudication."""

    model_config = ConfigDict(frozen=True)

    rule: UserRule
    accepted: bool
    rejected_reason: str | None = Field(
        default=None,
        description="Non-null only when accepted == False.",
    )
    conflicting_global_rule_id: str | None = Field(
        default=None,
        description="ID of the global rule that caused rejection, if any.",
    )


class ModuleRuleSet(BaseModel):
    """Rules that apply to a specific module."""

    model_config = ConfigDict(frozen=True)

    module: str
    rules: list[UserRule] = Field(default_factory=list)


class ProjectRuleSet(BaseModel):
    """Complete adjudication result â€“ ready to serialize into a LangGraph state."""

    model_config = ConfigDict(frozen=True)

    # Read-only platform rules (always enforced).
    global_rules: list[GlobalRule] = Field(default_factory=list)

    # User rules that passed adjudication.
    accepted_user_rules: list[RuleDecision] = Field(default_factory=list)

    # User rules rejected due to conflicts with global rules.
    rejected_user_rules: list[RuleDecision] = Field(default_factory=list)

    # Convenience: accepted user rules grouped by module (scope == MODULE only).
    module_rule_sets: list[ModuleRuleSet] = Field(default_factory=list)

    # Convenience: accepted user rules with scope == PROJECT.
    project_scoped_user_rules: list[UserRule] = Field(default_factory=list)
