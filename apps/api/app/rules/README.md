# Rules System Module

## Overview

The **Rules System** provides a robust framework for managing and adjudicating coding rules within the Atoms platform. It handles conflicts between platform-defined global rules and user-submitted rules, ensuring consistent enforcement across projects while respecting user preferences where appropriate.

## Architecture

```
app/rules/
├── __init__.py                  # Package marker
├── types.py                     # Pydantic models (GlobalRule, UserRule, ProjectRuleSet, etc.)
├── global_rules.py              # Platform-defined read-only rules
└── engine.py                    # Adjudication logic (decide_project_rules)
```

## Core Concepts

### Rule Types

1. **Global Rules** (`GlobalRule`)
   - Platform-defined, **read-only** rules that always take precedence
   - Examples: "No arbitrary code execution", "No secrets in source code"
   - Cannot be overridden or disabled by users

2. **User Rules** (`UserRule`)
   - Rules submitted by end-users or generated by upstream agents
   - Can be project-scoped or module-scoped
   - Subject to conflict resolution against global rules

### Rule Attributes

Every rule (global or user) has:
- **id**: Unique identifier (e.g., `G-001`, `U-042`)
- **title**: Short, descriptive name
- **description**: Detailed explanation
- **severity**: How strictly to enforce (`MUST` / `SHOULD` / `MAY`)
- **scope**: Where it applies (`PROJECT` / `MODULE`)
- **module** *(UserRule only)*: Target module name if `scope == MODULE`

### Priority & Conflict Resolution

**Priority order:** `Global Rules > User Rules`

A user rule **conflicts** with a global rule if:
- Their `id` values match exactly, **OR**
- Their `title` values match (case-insensitive)

When a conflict occurs:
- The user rule is **rejected**
- A human-readable `rejected_reason` is generated
- The `conflicting_global_rule_id` is recorded

Non-conflicting user rules are **accepted** and categorized by scope.

## API Reference

### Main Entry Point

```python
from app.rules.engine import decide_project_rules
from app.rules.global_rules import GLOBAL_RULES
from app.rules.types import UserRule, ProjectRuleSet

# Define user rules
user_rules = [
    UserRule(
        id="U-001",
        title="Use type hints",
        scope="project",
    ),
    UserRule(
        id="U-002",
        title="SQLAlchemy 2.0 style",
        scope="module",
        module="db",
    ),
]

# Run adjudication
result: ProjectRuleSet = decide_project_rules(GLOBAL_RULES, user_rules)
```

### ProjectRuleSet Structure

```python
@dataclass(frozen=True)
class ProjectRuleSet:
    # Read-only platform rules (always enforced)
    global_rules: list[GlobalRule]

    # User rules that passed adjudication
    accepted_user_rules: list[RuleDecision]

    # User rules rejected due to conflicts
    rejected_user_rules: list[RuleDecision]

    # Convenience: accepted rules grouped by module
    module_rule_sets: list[ModuleRuleSet]

    # Convenience: accepted project-scoped user rules
    project_scoped_user_rules: list[UserRule]
```

### Serialization

All models are **frozen Pydantic models** for stable JSON serialization:

```python
# Serialize to JSON
json_str = result.model_dump_json(indent=2)

# Deserialize from dict
result_copy = ProjectRuleSet.model_validate(json.loads(json_str))

# Use in LangGraph state
state["project_rules"] = result.model_dump()
```

## Usage Patterns

### Pattern 1: LangGraph Workflow Integration

```python
def adjudicate_rules_node(state: WorkflowState) -> WorkflowState:
    """Process user rules in a LangGraph workflow."""
    from app.rules.engine import decide_project_rules
    from app.rules.global_rules import GLOBAL_RULES
    from app.rules.types import UserRule

    # Parse user rules from state
    user_rules = [UserRule.model_validate(r) for r in state["user_rules_raw"]]

    # Adjudicate
    project_rules = decide_project_rules(GLOBAL_RULES, user_rules)

    # Store in state (as dict for JSON persistence)
    return {**state, "project_rules": project_rules.model_dump()}
```

### Pattern 2: Engineer Agent Consumption

```python
def engineer_agent_node(state: WorkflowState) -> WorkflowState:
    """Engineer agent reads adjudicated rules."""
    from app.rules.types import ProjectRuleSet

    # Reconstruct from state
    project_rules = ProjectRuleSet.model_validate(state["project_rules"])

    # Access global rules (always enforced)
    for gr in project_rules.global_rules:
        enforce_rule(gr)

    # Access module-specific rules
    current_module = state.get("current_module")
    if current_module:
        for module_set in project_rules.module_rule_sets:
            if module_set.module == current_module:
                for rule in module_set.rules:
                    enforce_rule(rule)

    # ... generate code ...
    return state
```

### Pattern 3: User Feedback on Rejections

```python
def provide_feedback(project_rules: ProjectRuleSet) -> list[str]:
    """Generate user-facing messages for rejected rules."""
    messages = []
    for decision in project_rules.rejected_user_rules:
        messages.append(
            f"⚠️ Your rule '{decision.rule.title}' was not applied: "
            f"{decision.rejected_reason}"
        )
    return messages
```

## Adding New Global Rules

Edit `app/rules/global_rules.py`:

```python
GLOBAL_RULES: list[GlobalRule] = [
    # ... existing rules ...
    GlobalRule(
        id="G-006",  # Next sequential ID
        title="Descriptive commit messages",
        description="All commits must have meaningful descriptions (>10 chars).",
        severity=Severity.SHOULD,
        scope=Scope.PROJECT,
    ),
]
```

**Guidelines:**
- Use sequential `G-XXX` IDs
- Populate all fields (no empty `description`)
- Choose appropriate `severity` and `scope`
- Document *why* the rule exists

## Testing

### Run Unit Tests

```bash
cd apps/api
pytest tests/test_rules_engine.py -v
```

**Coverage:**
- ✅ Conflict detection (ID and title)
- ✅ Non-conflicting acceptance
- ✅ Scope annotation (project/module)
- ✅ JSON serialization stability

### Run Validation Script

```bash
python validate_rules.py
```

Demonstrates end-to-end usage with sample data.

## Examples

See `example_workflow_integration.py` for a complete LangGraph integration example.

## Design Decisions

### Why Frozen Models?

All Pydantic models use `ConfigDict(frozen=True)` to ensure:
1. **Immutability**: Rules cannot be accidentally mutated after adjudication
2. **JSON stability**: Serialized output is deterministic
3. **Hashability**: Models can be used in sets/dicts if needed

### Why StrEnum?

Using `enum.StrEnum` (Python 3.11+) instead of `str, Enum` provides:
- Cleaner serialization to JSON strings
- Better type inference in modern type checkers
- Alignment with `pyproject.toml` (`target-version = "py312"`)

### Why Separate `global_rules.py`?

Keeps platform rules in a plain Python file for:
- Easy version control and code review
- No database/config overhead
- Allows commenting/documentation inline

## FAQ

**Q: Can users override global rules?**  
A: No. Global rules always take precedence. Conflicting user rules are rejected.

**Q: How do I add a user rule that applies to a specific module?**  
A: Set `scope=Scope.MODULE` and provide `module="module_name"`. The adjudication engine will group it in `module_rule_sets`.

**Q: What happens if a MODULE-scoped rule doesn't specify a module name?**  
A: It falls back to `project_scoped_user_rules` (edge case).

**Q: Can I have multiple global rules with the same title?**  
A: Not recommended. The conflict detector uses title matching, so duplicates could cause unexpected rejections.

**Q: How do I use this in the frontend?**  
A: The frontend sends raw rule dicts in the API request. The backend validates them into `UserRule` objects and runs adjudication. The result (as JSON) can be displayed to show which rules were accepted/rejected.

## Future Enhancements

Potential improvements (not yet implemented):

- **Rule categories**: Group rules by category (security, style, performance)
- **Conflict resolution strategies**: Allow users to acknowledge conflicts explicitly
- **Rule templates**: Pre-built user rule templates for common scenarios
- **Severity-based overrides**: Allow `MAY`-severity global rules to be overridden
- **Dependency rules**: Rules that depend on other rules being active
- **Per-file rules**: Scope rules to specific files or file patterns

## License

Part of the Atoms project. See top-level LICENSE file.
